---
title: "MSDS692 Practicum I - Online Retail II Data Set"
author: "Genet Sebehat"
date: "5/10/2020"
output:
  pdf_document: default
  word_document: default 
  html_document: default
---

```{r setup, include=FALSE} 

# Format R Code Automatically
library(formatR)       

knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
# Set so that long lines in R will be wrapped:
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=TRUE)
options(tinytex.verbose = TRUE)

``` 

```{r create_tryCatch}
x <- tryCatch(stop("Error"), error = function(e) e)
class(x) 
```

# Setup environment - clearing it out and loading any necessary libraries.
```{r setup_environment}
# Removes all objects to prevent results from previous runs being carried over into new runs
rm(list = ls()) 
# Clears the graphic plots window
graphics.off() 
# Clears the console
cat("\014")     
getwd()
setwd("C:/Users/owner/Desktop/Regis University/MSDS692/Week 1")
```

# library returns the list of loaded (or available) packages.
```{r load_libraries} 
library(corrplot)
library(corrgram)
library(dplyr)      
library(DT)         
library(ggplot2)    
library(ggthemes)
library(ggpubr)
library(lubridate)  
library(plotly)     
library(readxl)     
library(rfm)        
library(scales)     
```

# Load data
```{r load_data}
#specify the path to load the Online Retail excel file
OnlineRetail4 <- read_excel("C:/Users/owner/Desktop/Regis University/MSDS692/Week 1/Online Retail.xlsx")%>%
  
  mutate(Revenue = Quantity * UnitPrice)

```

# Pre-processing of the Data set

# Create sapply() takes data frame as input and gives output in vector or matrix
```{r find_missing_values}
# check missing values for each column
sapply(OnlineRetail4, function(x) sum(is.na(x)))
```

# Create na.omit() returns the object with listwise deletion of missing values
```{r create_new_dataset}
# Create new dataset without missing data
OnlineRetail5 <- na.omit(OnlineRetail4)

```

# Create colSums() computes the sums of matrix or array columns
```{r check_missing_val}
# Check the new dataset missing value after omitted null values
colSums(is.na(OnlineRetail5))
```

# Correlation: Correlation analysis is used to investigate the association between two or more variables.
```{r create_cor}
# create correlation
x <- OnlineRetail5$Quantity
y <- OnlineRetail5$Revenue
cor(x, y)

cor.test(x, y,
         alternative = c("two.sided", "less", "greater"),
         method = c("pearson", "kendall", "spearman"),
         exact = NULL, conf.level = 0.95, continuity = FALSE)

```

# Create correlation matrix
```{r create_corr_matrix}
# Create correlation matrix
test.data <- as.matrix(cbind(x,y))
test.names <- c("Quantity","Revenue")

M<-cor(test.data)
head(round(M,2),abbr.colnames = TRUE)
```

# Create correlation plot
```{r create_corrplot}
# corrplot graph
corrplot(M, method = "number")
```

# Create a Correlation plot
```{r create_correlation}
# Create Correlation plot
ggscatter(OnlineRetail5, x = "Quantity", y = "Revenue",
          add = "reg.line", conf.int = TRUE,
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "Quantity", ylab = "Revenue", color = "blue")

```


#Clustering
#Clusering is the procedure of partitioning a set of observations into a set of meaningful subclasses or clusters.
#For Example, clustering technique helps in business area to discover distinctive group of customers to develop targeted marketing programs.

#Clustering methods
#•	Partitioning techniques
#o	Find centers of clusters among the observation and each one is signed to the cluster that cluster that has the closest center. EX. Kmeans (unsupervised learning technique)
#•	Hierarchical techniques
#o	Connect the observations based on their similarity to form cluster.  EX. Hierarchical clustering 
#•	Mode-base methods
#o	Use probabilistic distribution to create cluster. EX. Mixture models  

#Customer segmentation for this analysis was showed based on their purchase behavior, the features to be analyzed were Recency, Frequency and Monetary Value, (RFM) for short.

# RFM is defined as follow:
#•	Recency: Number of days the user has been inactive, from the moment of last purchase to the latest time in the dataset.
#•	Frequency: Total number of transactions completed by a customer in a year.
#•	Monetary Value: Total revenue generated by the customer in a year.

# I will create three or more clusters. This helps the Online Retailer define Low, Medium and High values users.

# Data Preprocessing that identifying and handling duplicated values

# Create which function that returns the indices of the logical object when it is TRUE
```{r create_which_fun}
# Check with duplicated values
dupes <- which(duplicated(OnlineRetail4))

# Subsetting out the duplicated values
OnlineRetail5 <- OnlineRetail4[-dupes,]
```

# Create complete.cases() Return a logical vector indicating which cases are complete
```{r create_complete_case_fun}
# Create complete.cases function
OnlineRetail3 <- OnlineRetail5[complete.cases(OnlineRetail5),]

# Removing not valuable data sets
rm(OnlineRetail4, dupes)
rm(OnlineRetail5)

```

# Create a data table
```{r create_datatable}
# Showing the first few observations of the dataset
DT::datatable(head(OnlineRetail3, 20),
              rownames = FALSE,
              options = list(
                pageLength = 5))

```

# Filter for top 10 countries
```{r create_filter}
# Filter for top 10 countries by transaction
Txn_per_ctry <- OnlineRetail3 %>%
  group_by(Country) %>%
  summarise('Number of Transcations' = n()) %>%
  arrange(desc(`Number of Transcations`)) %>%
  top_n(10)

names(Txn_per_ctry) <- c("Country", "Number of Transactions")
print(Txn_per_ctry)
```

# Top 5 countries by number of transactions
```{r create_his1}
#Create histogram
Txn_per_ctry_Vis <- ggplot(head(Txn_per_ctry,5), aes(x=reorder(Country,-`Number of Transactions`), y=`Number of Transactions`)) +
  geom_bar(stat = 'identity', fill = 'light green') +
  scale_y_continuous(labels = comma) +
  geom_text(aes(label = `Number of Transactions`), vjust = -0.5) +
  ggtitle('Top 5 Countries by Number of Transactions') +
  xlab('Countries') +
  ylab('Number of Transactions') +
  theme_minimal() 
print(Txn_per_ctry_Vis)

``` 

# Transactions per Country Table
# This shows a complete list of countries represented among the online retailers’ customers along with their total transactions. Most of this online retailer’s transactions involved customers residing in European Union (EU) countries; the online retailer is based in the United Kingdom (UK).

# Create a data table to display table of transactions per Country
```{r create_txn_table}
# Display table of transactions per Country
DT::datatable((Txn_per_ctry),
              rownames = FALSE,
              options = list(
              pageLength = 10)) 

```


# Filter Transactions in UK
# This segmentation analysis, only users and transactions that happened in the UK were analyzed.
```{r create_Code_filter}
#Filter UK customers
UK_Online_Rtl <- OnlineRetail3 %>%
  filter(Country == 'United Kingdom')

```

# Recency: Recency was calculated as one of the features for the segmentation analysis. In this case recency has been calculated as follows, time of customer’s last purchase minus the last transaction date in days.

# Recency Statistics indicates that how long customer have been inactive. 
```{r create_df_uniq_CID}
# Creating a dataframe with unique Customer ID
Users_Rec <- UK_Online_Rtl %>% 
  group_by(CustomerID) %>%
  summarise(Last_Cust_Activity = max(InvoiceDate)) %>%
  mutate(Last_Invoice = max(Last_Cust_Activity)) 
  
# Recency 
Users_Rec$Recency <- round(as.numeric(difftime(Users_Rec$Last_Invoice, Users_Rec$Last_Cust_Activity , units = c("days"))))

Users_Rec <- Users_Rec %>%
  select(CustomerID, Recency)

# Recency refers to the amount of days that a customer has remained inactive. 

# From the moment of last purchase up to the moment of the last invoice in the dataset

# Build a histogram of Recency
print(summary(Users_Rec$Recency))

```

# As the above summary of statistics shows, 50% of the site’s users show less than 49 days of not active.  On average, however, customers went three months without making a single purchase, and a small customer that have not made a single transaction in over a year. 50% of the users are below 49 days of inactivity.

# Recency Histogram
```{r create_histogram}
# create histogram
ggplot(Users_Rec, aes(Recency, col ="brown")) +
  geom_histogram() +
  ylab('Number of Customers') +
  theme_minimal()

```

# Based on the above histogram, most clients have been active over the last 90-100 days. There are no benchmarks to compare this with, but three months of customer inactivity does not sound terrible, especially after it was discovered in the previous analysis that the company has not been acquiring users as quickly as it used to. However, some of these customers have gone over 140 days without making a single purchase.


# Purchase frequency was calculated by counting the number of times a customer made a transaction with the online retailer over the period of a year. 

# Frequency Statistics
```{r create_num_txn}
# Calculating the number of transaction per 'Customer ID'
User_freq <- UK_Online_Rtl %>%
  group_by(CustomerID) %>%
  summarise(Frequency = n())

# Summary Statistics of Number of Purchases for each user
summary(User_freq$Frequency)

```

# The above results show how often customers purchased from the online retailer.  Customers make an average of 90 transactions a year, with 75% of users making less than 100 purchases a year.   As shown in the above statistical summary, there are big difference between the 3rd quartile (99) and maximum number of purchases (7,812).


# Frequency Boxplot:  Since there is a remarkable difference between the 3rd Quartile and Max value, the boxplot graph will be divided in two.  

# Create the first Boxplot graph which displays Customers in the 3rd quartile
```{r create_boxplot}
Vis_3Q <- User_freq %>%
  filter(Frequency <= 99)

Outliers <- User_freq %>%
  filter(Frequency >= 500)

# Plotting first 3 Quartile
Vis_3Q <- ggplot(Vis_3Q, aes(CustomerID, Frequency)) +
  geom_boxplot() +
  ylab('Number of Purchases per Customer') +
  ggtitle('Purchase Frequency - First 3 Quartiles') +
  theme(axis.ticks.x = element_blank()) +
  theme_minimal() 
  
print(Vis_3Q)
```

# Create the second Boxplot graph which displays Customers in the 4th quartile
```{r create_plot_last_Qr}
# Plotting last Quartile
Outliers_vis <- ggplot(Outliers, aes(CustomerID, Frequency)) +
  geom_boxplot() +
  ylab('Number of Purchases per Customer') +
  scale_y_continuous(labels= scales::comma) + 
  ggtitle('Purchase Frequency - Outliers') +
  theme(axis.ticks.x = element_blank()) +
  theme_minimal()
print(Outliers_vis)

```

# Monetary Value
# Lastly, the last calculation to build before creating the cluster segmentation model is Monetary Value. This refers to the total sum of revenue generated by a given user over the course of a year.

# Monetary Value Statistics

# As the following block of code shows, revenue was estimated calculating the unit price and quantity per transaction and grouping by Customer ID.
```{r create_calc_rev}
# Calculate Revenue per Customer ID
Users_Mon_Value <- UK_Online_Rtl %>%
  mutate(Revenue = Quantity * UnitPrice) %>%
  group_by(CustomerID) %>%
  summarise(Mon_Value=sum(Revenue))

# Summary Statistics
summary(Users_Mon_Value$Mon_Value)
```
# As the above results show, there are customers who have negative revenue that is, apparently there are negative numbers in the price column. This could suggest purchase returns, and this is an important assumption as we keep working on the segmentation.

# Monetary Value Histograms
# Plot two sets of users. The first histogram shows Customers below the 3rd Quartile
```{r create_hist2}
# Create filter <= 15000 monetary value
MonV_3Q <- Users_Mon_Value %>%
  filter(Mon_Value <= 15000)

# Create filter > 15000 monetary value
MonV_Outliers <- Users_Mon_Value %>%
  filter(Mon_Value > 15000)

# Visualizing a histogram of revenue generated by user
MonV_3Q_Vis <- ggplot(MonV_3Q, aes(Mon_Value, col="yellow")) +
  geom_histogram() +
  ggtitle('Revenue of Users - Below $15K') +
  ylab('Number of Users') +
  xlab('Revenue') +
  scale_x_continuous(labels = scales::dollar) +
  scale_y_continuous(labels = scales::comma)
  
print(MonV_3Q_Vis)
```

# Create the second histogram - customers with revenue greater than 15k a year.
```{r create_histogram}
# Visualizing histogram of Revenue Outliers
Outliers_Vis <- ggplot(MonV_Outliers, aes(Mon_Value, col="brown")) +
  geom_histogram() +
  ggtitle('High Revenue Users - Outliers') +
  ylab('Number of Users') +
  xlab('Revenue') +
  scale_x_continuous(labels = scales::dollar, breaks = c(50000, 100000, 150000, 200000, 250000, 300000)) +
  scale_y_continuous(labels = scales::comma)
print(Outliers_Vis)

```

# Merging Recency, Frequency and Monetary Value. RFM

# Here I begin to merge the datasets for the cluster segmentation. So far, three features have been constructed for the model: The Recency, Frequency, and Monetary Value of each customer. These three variables are now linked to the respective Customer ID.

# Create merge function
```{r create_rfm_table}
# Merging Recency & Freq
RFM_users <- merge(Users_Rec, User_freq) 

# Merging Monetary Value
RFM_users <- merge(RFM_users, Users_Mon_Value)

# Create data table
DT::datatable((RFM_users),
              rownames = FALSE,
              options = list(pageLength = 10))

```

# The above table shows the Users’ RFM table. This table includes each Customer ID and its respective RFM features. The information in this table will be used for customer segmentation.


# Statistical Clustering - KMeans
# The segmentation will be performed using KMeans clustering, which is a simple and elegant way of subsetting customers into non-overlapping segments.

# Create KMeans function
```{r create_kemans_fun}
# Create Clusters based on the RFM Table using Unsupervised Statistical Learning
set.seed(400)

# Perform kmeans with RFM variables and creating 3 clusters.
clusters <- kmeans(scale(RFM_users[,2:4]), 3, nstart = 1) #  

# Attach the results to Customers ID to identify each customer's cluster
RFM_users$Cluster <- as.factor(clusters$cluster) 
```

# Create KMeans function
```{r create_clusters}
# Create Clusters based on the RFM Table using Unsupervised Statistical
set.seed(400)
clusters <- kmeans(scale(RFM_users[,2:4]), 3, nstart = 1) 

# Attach the results to Customers ID to identify each customer's cluster
RFM_users$Cluster <- as.factor(clusters$cluster) 
```


# Defining Users’ Value to the Business - KMeans

# There are three different clusters based on customers’ behavior with the Online Retailer. We may look at the differences in these clusters in order to identify High Value Customers, Medium Value Customers, and Low Value Customers.
```{r create_value_cus}
KMeans_R <- RFM_users %>%
  group_by(Cluster) %>%
  summarise('Number of Users' = n(),
            'Recency Mean' = round(mean(Recency)),
            'Frequency Mean' = scales::comma(round(mean(Frequency))),
            'Monetary Value Mean' = scales::dollar(round(mean(Mon_Value))),
            'Cluster Revenue' = scales::dollar(sum(Mon_Value))
            )
# Create data table to display cluster means to identify their value to the business 
DT::datatable((KMeans_R),
              rownames = FALSE) 
```

# The above table shows the 3 segments of customers

# Create histogram that displays number of cluster
```{r create_no_users_per_cluser}
Cluster_number <- ggplot(KMeans_R, aes(Cluster, `Number of Users`)) +
  geom_text(aes(label = `Number of Users`), vjust = -0.3) +
         geom_bar(aes(col=Cluster), stat='identity') +
  ggtitle('Number of Users per Cluster') + 
  xlab("Cluster Number") +
  theme_classic()
         print(Cluster_number)
         
```

# Summary - KMeans Segmentation
# Customers of the business have been clearly identified into three groups using the KMeans clustering algorithm.

# These clusters can help the business to better understand its customers in terms of revenue generated, frequency of purchases, and days of inactivity. This will help inform their marketing strategies, allowing them to maintain and/or improve the profitability of different type of customers.

# In order to improve this clustering analysis, I will implement Hierarchical Clustering.

# Monetary Value was selected as the value for the further segmentation, with frequency and recency as estimator for it.

# Created hiererchical clustering
```{r create_cluster_three}
# Create three cluster
Cluster_tree <- RFM_users %>%
  filter(Cluster == '3') %>%
  select(Frequency, Mon_Value, Recency)

fit_tree <-rpart(Mon_Value ~ ., 
                 data=Cluster_tree,
                 method = 'anova', 
                 control= rpart.control(cp=0.0127102))

rpart.plot(fit_tree, type=1,extra=1, box.palette=c("gray","lightgreen"))

```
# The above result shown hierarchical clustering graph and how to read the graph as follows:
# Read the statement on top of the model and move right for “no” or left for “yes”.
# The top number in the bubble represents the average monetary value for the group
# n = represents the number of variables that are part of the group

# Summary Hiererchical Segmentation
# This sub-segmentation of Cluster three divided the segment into four smaller clusters.

# The above results show (from low value to high value customers):  
# 1,724 customers that purchased less than 75 times, average monetary value of $733.
# 854 customers that purchased more than 75 times, average monetary value of $2,383 (significantly higher than the previous group).
# 231 customers that purchased more than 215 times and have not purchased over the last five or more days. Average Monetary Value of $4,813.
# 125 customers that purchased more than 215 times and have purchased within the last five days. Highest average monetary value of $8,556.
# This last sub-segment of 125 customers represents the most valuable customers within Cluster 3. 
